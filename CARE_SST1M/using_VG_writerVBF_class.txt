Version 1.0
Charlie Duke
Grinnell College

May 8, 2010

The current version of GrISU uses the GrISU_writeVBF class (see the 
GrISU/Simulation/Detector directory for the source code) for writing vbf
files based on grisudet simulations.  The class is not independent of 
the data and parameter structures used in grisudet and defined in 
GrISU/Simulation/Detector/definition.h.

Based on GrISU_writeVBF, the new class VG_writeVBF is totally independent
of the grisudet parameters and uses parameters and data passed into the 
class via various setters and other class methods.  Thus, it is available
for use in any simulation package. This class provides transparent access
to the vbf methods and generates data and pedestal packet event times 
based on a given start time, mean data frequency, and time between 
pedestal events. Thus, the user does not have to understand the details
of the VAtime class that manages these time parameters.

I replaced the GrISU_writeVBF class with the VG_writeVBF class in my local
version of grisudet so I could compare the vbf files generated by the 
standard GrISU_writeVBF class with the files generated by the new 
VG_writeVBF class, using of course the same photon files as input to
grisudet. (and using care with use of the random number generator within 
the writeVBF classes - if you wish to make these comparisons, you must
comment out the single random number produced in the VBF writer classes and
raplace this call with a given value for this random number. I used 0.8.
This is necessary since GrISU_writeVBF uses the random_gen.h random number
generator and VG_writeVBF uses TRandom3. With different random number
generator instances, the grisudet outputs will be different following the
first event time calculation by the VBF writer).  The vbf files produced
by the two classes were exactly the same, with the exception of the 
corrected VEvent TriggerMask in the VG_writeVBF class.


*****************************  USAGE  ************************

In understanding the following details, it's best to open the doxygen
generated index.html file in the GrISU/Simulation/Detector/documentation
directory

The calls shown below are from the version of grisudet using VG_writeVBF

I. Include files and initialization 
  A.  include files and enum, at head of grisudet

     enum SimulationPackageCodes   {KNOWNNOT,LEEDS,GRISU,KASCADE,CORSIKA,UCLA};
     #include "VG_writeVBF.h"

  B. Instantiation

 
   *******  make a VG_writeVBF object for data files ******
   op->writeVBF = new VG_writeVBF(ta->nbr_tel,
                                    numPixTel,
                                    vbffilename,
                                    op->vbfp.runnumber,
                                    debugLevel);
  }

   *******  if necessary make a second VG_writeVBF object for peds ****
   do not make this object if the data vbf file also contains pedestals
       
   if (stp->is_a_pedvbf) { // open vbf ped file if necessary

     std::vector<unsigned>numPixTel;
      for (int tel=0;tel<ta->nbr_tel;tel++) {
        numPixTel.push_back( (unsigned)ta->scope[tel].camera.nbr_pmt);
      }

    std::string vbffilename(stp->vbfpedout);   
    std::cout << "****** instantiating vbf writer for peds" << std::endl;
    int debugLevel = 0;
    op->writepedVBF = new VG_writeVBF(ta->nbr_tel,
                                    numPixTel,
                                    vbffilename,
                                    op->vbfp.runnumber,
                                    debugLevel);

  C. Simulation Header

     The first packet of the vbf file contains only the Simulation Header
     and can be written whenever the necessary information is available in
     the code. Here, I'm including all the grisudet code for completeness.

     The following code is in a loop and is executed only once since
     op->vbfp.simul_header_flag flag is set within the if statement.


   if ( (op->vbfp.is_a_vbf) && (!op->vbfp.simul_header_flag) )  {
      
      if ( (op->hobs < 0.0) )  {
        showxerror("hobs < 0.0 and trying to make vbf header and peds");
      }
  
      // set particle IDtype for both writers
      uint32_t particleVBFtypeID = 0; // particle id type 1 for corsika
      (op->writeVBF)->setParticleIDType(particleVBFtypeID);
      if (op->vbfp.is_a_pedvbf==1) {
        (op->writepedVBF)->setParticleIDType(particleVBFtypeID);
      }
 
     // create simulation headers

      //std::cout << "make vbf simulation header for data" << std::endl;

      for (int tel = 0; tel < ta->nbr_tel; tel++) {
        float telSouth = -ta->scope[tel].yfield;
        float telEast  = ta->scope[tel].xfield;
        float telUp    = ta->scope[tel].zfield;
        (op->writeVBF)->setTelescopeLocations(tel,
                                              telSouth,
                                              telEast,
                                              telUp);

        float ffocln = 1000.0*ta->scope[tel].mirror.foclength;

        for (int pix = 0; pix < ta->scope[tel].camera.nbr_pmt;pix++) {
          float pixEast = (RAD2DEG)*
            atan(ta->scope[tel].camera.pmt[pix].x/ffocln);  
          float pixUp = (RAD2DEG)*
            atan(ta->scope[tel].camera.pmt[pix].y/ffocln);
          float pixRad = (RAD2DEG)*
            atan(ta->scope[tel].camera.pmt[pix].radius/ffocln);
          (op->writeVBF)->setPixelLocations(tel,pix,
                                            pixEast,pixUp,pixRad);
        } 
      }

      std::string configFile("testConfigFileString");
      std::string simulator("duke");
      float obserAltitudeM = op->hobs; 
      uint32_t simulationPackage = GRISU;
      uint32_t atmosphericModel = 0;

      //(op->writeVBF)->setDebugLevel(2);
      // Note that the makeSimulationHeader method makes and stores
      // the vbf packet - in contrast to data packets where there is an
      // explicit VG_writeVBF::makePacket() method call requirement

      (op->writeVBF)->makeSimulationHeader(configFile,
                                           simulator,
                                           obserAltitudeM,
                                           simulationPackage,
                                           atmosphericModel);

      op->vbfp.simul_header_flag = true;  // set flag after writing header

      // set pedestal parameters for data writeVBF object
      
      bool makePedsFlag = op->vbfp.ped_flag;
      int pedTimeInterval = op->vbfp.ped_time_interval;
      std::string pedFileName("");
      if (stp->is_a_pedvbf) {
        pedFileName = stp->vbfpedout;
      }

      (op->writeVBF)->setPedestalParameters(makePedsFlag,
                                            pedTimeInterval,
                                            pedFileName);

      //std::cout << " setFirstEventTimeString for data" << std::endl;

      std::string fFirstValidEventTimeStr;
 
      if (!op->vbfp.is_a_starttime) {
        fFirstValidEventTimeStr = "2006-11-28 02:00:00.000000000 GPS";
      }
      else {
        std::string tstr1(op->vbfp.time1);
        std::string tstr2(op->vbfp.time2);
        std::string tstr3(op->vbfp.time3);
        fFirstValidEventTimeStr= tstr1 + " " + tstr2 + " " +tstr3;
      }
 
      (op->writeVBF)->setFirstEventTimeString(fFirstValidEventTimeStr);

      double EventRatePerSec = op->vbfp.meanshowerfreq;
      (op->writeVBF)->setShowerFrequencyHz(EventRatePerSec);

      // makeEventTimeClasses for data VBF writer
      (op->writeVBF)->makeEventTimeClasses();
 
      // if necessary setup the vbf writter object for pedestals
      // don't do this unless you wish to have a separate pedestal vbf file
 
     if (op->vbfp.is_a_pedvbf==1) {

        // some of this is a repeat from above, to be fixed later
        for (int tel = 0; tel < ta->nbr_tel; tel++) {
          float telSouth = -ta->scope[tel].yfield;
          float telEast  = ta->scope[tel].xfield;
          float telUp    = ta->scope[tel].zfield;
          (op->writepedVBF)->setTelescopeLocations(tel,
                                                   telSouth,
                                                   telEast,
                                                   telUp);
          
          float ffocln = 1000.0*ta->scope[tel].mirror.foclength;
          
          for (int pix = 0; pix < ta->scope[tel].camera.nbr_pmt;pix++) {
            float pixEast = (RAD2DEG)*
              atan(ta->scope[tel].camera.pmt[pix].x/ffocln);  
            float pixUp = (RAD2DEG)*
              atan(ta->scope[tel].camera.pmt[pix].y/ffocln);
            float pixRad = (RAD2DEG)*
              atan(ta->scope[tel].camera.pmt[pix].radius/ffocln);
            (op->writepedVBF)->setPixelLocations(tel,pix,
                                                 pixEast,pixUp,pixRad);
          } 
        }
        
        //make vbf simulation header for peds
        (op->writepedVBF)->makeSimulationHeader(configFile,
                                                simulator,
                                                obserAltitudeM,
                                                simulationPackage,
                                                atmosphericModel);
        
        //setPedestalParameters for pedestals
      
        bool makePedsFlag = op->vbfp.ped_flag;
        int pedTimeInterval = op->vbfp.ped_time_interval;
        std::string pedFileName("");
        if (stp->is_a_pedvbf) {
          pedFileName = stp->vbfpedout;
        }
        
        (op->writepedVBF)->setPedestalParameters(makePedsFlag,
                                              pedTimeInterval,
                                              pedFileName);
      
        //setFirstEventTimeString for peds file
        // much of the following is probably unnecessary since later
        // the event times in the pedestal vbf writer is synchronized with
        // the event times of the data vbf writer. But, doing this doesn't
        // hurt.        

        if (!op->vbfp.is_a_starttime) {
          fFirstValidEventTimeStr = "2006-11-28 02:00:00.000000000 GPS";
        }
        else {
          std::string tstr1(op->vbfp.time1);
          std::string tstr2(op->vbfp.time2);
          std::string tstr3(op->vbfp.time3);
          fFirstValidEventTimeStr= tstr1 + " " + tstr2 + " " +tstr3;
        }
        
        (op->writepedVBF)->setFirstEventTimeString(fFirstValidEventTimeStr);
        
        EventRatePerSec = op->vbfp.meanshowerfreq;
        (op->writepedVBF)->setShowerFrequencyHz(EventRatePerSec);
               
        //makeEventTimeClasses for ped file
        (op->writepedVBF)->makeEventTimeClasses();
      }
    }




  D. Data packet (I'll cover Pedestal packets in the next section)

     // where you are ready to create, fill, and store a vbf data 
     // packet, call the grisudet procedure output_event_vbf.  Here's
     // the code

     
int output_event_vbf(struct array *ta,struct cfront *cerfrnt,                 
		 struct signals *event,struct operate *op,
                 struct faccess *stp)

     /* write the output event record
     */
{
  int tel,pix; /*Telescope and pixel identifier*/
  int i; /*Sample index*/

  int ifirst_init, ilast_init;
  int ifirst; /*For one telescope index of the first sample to be written*/
  int ilast; /*For one telescope index of the last sample to be written*/
  int digit_pms; /*Digitized sample value*/  

  // return if no array trigger and we do not require 

  VG_writeVBF *vw = op->writeVBF;  // shorthand easier to read

  // set telescope azimuth and elevation vectors in vbf writer
  for (int tel1=0;tel1 < ta->nbr_tel;tel1++){
    float azimDeg =ta->scope[tel1].azim_deg; 
    float elevDeg = ta->scope[tel1].elev_deg;
    unsigned telu = (unsigned)tel1;
    (op->writeVBF)->setAzimElevTelDeg(telu,azimDeg,elevDeg);
    
    // do the same if there is a separate pedestal vbf file
    if (op->vbfp.is_a_pedvbf) {
      (op->writepedVBF)->setAzimElevTelDeg(telu,azimDeg,elevDeg);
    }
  }

  // if no array trigger, make empty packet if necessary, 
  if ( (event->array_trigger < 1.0) ) {

    // there is no array trigger and we only want to store the simulation
    // data header information, e.g. shower energy, etc. So only write the
    // header to the packet and return

    if (op->vbfp.write_packet_allevents) {

      vw->setDataEvent();  // tell vw that the event is a data event and
                           //      not a pedestal event

      vw->makePacket();   // create an empty packet

      // make simulation data header and add to packet
      vw->makeVSimulationData( cerfrnt->prim.energy * 1000.0,
                               90.0 - cerfrnt->prim.elev_deg,
                               cerfrnt->prim.azim_deg,
                               cerfrnt->prim.ximpac,
                               -cerfrnt->prim.yimpac,
                               op->hobs,
                               cerfrnt->prim.type);

      // the storePacket method stores the packet and increments the eventtime.
      vw->storePacket();           // do a writePacket
     
      if ( op->vbfp.is_a_pedvbf ) {
        // if separate vbf ped file, synchronize eventtimes
        (op->writepedVBF)->setEventTime(vw->getEventTime());
      }
    }
    return 0;
  }
  
  bool triggered_readout_bool;

  // do we read out all cameras or only the triggered cameras?
  if (op->vbfp.triggered_readout == 0 ) {
    triggered_readout_bool = false;
  }
  else {
    triggered_readout_bool = true;
  }
  vw->setTriggeredReadout(triggered_readout_bool);

  vw->setDataEvent();  // this is data event not a pedestal event

  vw->makePacket();    // create a new packet

  // make and store the simulation data header in the packet 
  vw->makeVSimulationData(1000.0*cerfrnt->prim.energy,
                          90.0 - cerfrnt->prim.elev_deg,
                          cerfrnt->prim.azim_deg,
                          cerfrnt->prim.ximpac,
                          -cerfrnt->prim.yimpac,
                          op->hobs,
                          cerfrnt->prim.type);
  
  vw->makeArrayEvent();  // make an arrayevent, will add to it and store later

  // setup trigger vector of triggered telescopes
  std::vector<int> arrayTriggerV;
  arrayTriggerV.resize(4,0);                // FIX: arbitrary telescope number
  for(int tel1=0;tel1<ta->nbr_tel;tel1++){
    if (event->local_trigger[tel1] > 0.5 ) {
      arrayTriggerV[tel1] = 1;
    }
    
  }
  
  // make an array trigger
  //vw->setDebugLevel(1);
  vw->makeArrayTrigger(arrayTriggerV);
  //vw->setDebugLevel(0);
  
  /*Create the tracking information record for each telecope*/
  /*We then write FADC output*/
  if ((ta->elec.fadc.onoff)&&(!op->nopix)){
    for (tel=0;tel<ta->nbr_tel;tel++){
      /* create event from this telescope? 
         always yes if ftriggered_readout is false;
         otherwise only if telescope triggers
      */
      // make an event for each triggered telescope (or all telescopes)
      if((triggered_readout_bool) || 
         (event->local_trigger[tel]) ) {
        
        vw->setTelescope(tel);  // set current telescope in VBF writer
        //vw->setDebugLevel(1);
        vw->makeEvent();        // make the individual telescope event
        //vw->setDebugLevel(0);
        /*For that telescope fixes the index of the first 
          and last samples to be written to the output.*/
        /*
          If there are no photoelectrons produced from tel, then the sgnl_start time
          will be INFINITY_1, and the time samples will be filled only with noise
          on top of the pedestal. So, in that case, the first time slice can start anywhere
          in the array, e.g. at ta->elec.fadc.trig_advance.
          C.Duke 23July2009
        */
        // the following will depend on how you handle the time slices
        if (event->sgnl_start[tel] < (INFINITY_1) ) {

          ifirst_init=(int)(floor((event->local_trigger_time[tel]
                                   -event->sgnl_start[tel])/
                                  ta->elec.sampl_tim)-ta->elec.fadc.trig_advance);
        }
        else {
          ifirst_init = (int)ta->elec.fadc.trig_advance;
          //printf("nbr_evt tel ifirst_init %d %d %d\n",nbr_evt,tel,ifirst_init);
        }
        ilast_init=ifirst_init + ta->elec.fadc.nbr_sgn_samp_out;
        
        for(pix=0;pix<ta->scope[tel].camera.nbr_pmt;pix++){
          vw->setPixel(pix);         // set the pixel number in the VBF writer
          vw->setChargePedHigain();  // initialize settings

          /*For one channel, the record starts with the event number, 
            the telescope identification and the pixel identification*/
          //if(event->fired[tel][pix]){
          //fprintf(op->outpu,"R %d %d %d ",nbr_evt,tel+1,pix+1);
          
          /* introduce time offset delay - pulse starts later in array */
          ifirst = ifirst_init;
          ilast  = ilast_init;
          float hilofact=1.0;
          //if (tel==2) printf("line 2257 %d %d %d %d %d\n",nbr_evt,tel,pix,ifirst,ilast);

          // hilofact is a float: either 1.0 or the the hi/lo gain ratio if
          // time slice exceeded the gain threshold set in the config. file
          hilofact = get_hilo_switch(tel,pix,ifirst,ilast,ta,event);

          if (hilofact > 1.0) {
            vw->setHiLoGain(true);   // set hilo gain switch to lo gain
          }
          else {
            vw->setHiLoGain(false);   // set hilo gain switch to hi gain
          }  
          
          // set trigger bit, initialized to false
          if (event->fired[tel][pix] == 1) {
            vw->setTriggerBit(true);
          }
          else {
            vw->setTriggerBit(false);
          }
          
          /*Digitize and printout the samples*/
          for(i=ifirst;i<ilast;i++){
            digit_pms=fadc_output(event->pms[tel][pix][i]/hilofact,ta);
            int timebin = i - ifirst;
            vw->storeSample(timebin,digit_pms);  // store the sample
          }	  
               
        } // pixel loop

        vw->storeEvent();  // store the event for this telescope
      } // if event

    }   // telescope loop

    vw->storeArrayTrigger();     // store in arrayevent
    vw->storeArrayEvent();       // store in packet

    vw->storePacket();           // do a writePacket, increment event time.

  }
  
  return 0;
}



  E. Pedestals, 

  See above code to set up separate peds writeVBF object

  after simulating an event but before calling the output_event_vbf
  procedure (see above). Note, there is a make pedestal flag that is set in
  the writeVBF object when the event time exceeds the time previously set
  to make the next pedestal. Querying makePedestalNow() tells you if it's
  time to make a pedestal.  If it's time, then call the procedure to make
  the next pedestal. In grisudet this is fadc_pedestal_out_vbf.

  Here's the check for pedestal time  

   // check to see if we need to produce a vbf pedestal 
    if ( ((op->vbfp.is_a_vbf==1) &&
          (op->vbfp.ped_flag) &&
          (op->writeVBF->makePedestalNow()) ) ) {
      if ((dummy=fadc_pedestal_out_vbf(skyns,ta,op)))
        return showerror("While generating vbf fadc pedestal output");
    }

  And, here's the code for fadc_pedestal_out_vbf from grisudet.c


int fadc_pedestal_out_vbf(struct bckgrnd *skyns,struct array *ta,
                     struct operate *op)
     /* generate the FADC pedestal output
        writing to asci file if is_a_vbf = 0 OR
        writing to vbf file if is_a_vbf = 1
     */
     
{
  int tel;   /*Telescope index*/
  int pix;   /*Pixel index*/
  int i;
  int ipedv;   /*Integer pedestal record sample value*/
  float fpedv; /*Pedestal record sample value before digitization*/

  int inoise;

  int ped_samp_out;  // value depends on vbf out or asci out
  
  int vbf = op->vbfp.is_a_vbf;  // flag for vbf lines
  
  ped_samp_out = ta->elec.fadc.nbr_sgn_samp_out;  
  
  VG_writeVBF *pedVBF;
  pedVBF = 0;
  
  if(ta->elec.fadc.onoff){

    if (vbf==1) {
      // set pointer to vbf file for pedestals, data or separate ped vbffile
      if (op->vbfp.is_a_pedvbf == 0) {
        pedVBF = op->writeVBF;
      }
      else {
        pedVBF = op->writepedVBF;
        // this will allow the vbf writer to control the ped time
        pedVBF->setEventTime(op->writeVBF->getEventTime());
        pedVBF->setPedEventTime((op->writeVBF)->getPedEventTime());
      }
      
      pedVBF->setPedestalEvent();  // tell the writer this is peds packet
  
      for (unsigned tel1=0;tel1<(unsigned)ta->nbr_tel;tel1++) {
        pedVBF->setAzimElevTelDeg(tel1,ta->scope[tel1].azim_deg,
                                  ta->scope[tel1].elev_deg);
        
      }
      pedVBF->makePacket(); // make packet,
      
      pedVBF->makeArrayEvent();  // make array event

      //pedVBF->setDebugLevel(1);
      pedVBF->makeArrayTrigger(); // number of triggering telescopes = all
                                  // telescopes, 
        
      for (tel=0;tel<ta->nbr_tel;tel++){
        
        pedVBF->setTelescope(tel);  // set telescope number, starting from zero
        
        pedVBF->makeEvent();  // make event for this telescope
       
	for(pix=0;pix<ta->scope[tel].camera.nbr_pmt;pix++){

          pedVBF->setPixel(pix);  // set pixel number

          // set charge and pedestal to zero here
          pedVBF->setChargePedHigain();
          
          /*A starting point is randomly selected along the 
            simulated noise records*/
          inoise=(int)(floor(rndm()*(ta->elec.nbr_ped_samp-1)));

	  for(i=0;i < ped_samp_out;i++){
	    /*Converts the bg signal in mV*/
	    fpedv=voltconv(skyns->bgsign[tel][pix][inoise],ta);
	    /*Adds electronics noise*/
	    fpedv=fpedv+ta->elec.anlg.electro_noise*gasdev();
	    /*Digitize*/
	    ipedv=fadc_output(fpedv,ta);

            // store time slice in vbf event, note ipedv is int
            // data type, cast to unsigned byte in store_sample.
          
            pedVBF->storeSample(i,ipedv);
           
             /*In case we arrive at the end of the simulated noise record 
              we go to the begining*/
            inoise=inoise+1;
            if(inoise>=ta->elec.nbr_ped_samp) inoise=0;
	  }
	} // pixel loop
 
        pedVBF->storeEvent();
        
      }   // telescope loop
  
      pedVBF->storeArrayTrigger();

      pedVBF->makeVSimulationData();  // take the parameter defaults 
      pedVBF->storeArrayEvent();      // store the arrayevent

      pedVBF->storePacket();          // store the packet

      fprintf(stderr,"          storing vbf pedestal packet\n");
      

      // synchronize the times if using a separate ped vbf file.
      if ( op->vbfp.is_a_pedvbf ) {
        // if separate vbf ped file, set next ped time in
        // the vbf data file where time comparisons are made
        (op->writeVBF)->setPedEventTime(pedVBF->getPedEventTime());
        (op->writeVBF)->incrementPedTime();

      }
    }
    
  }
  return 0;

}


F.  Finish up 


  if (stpilot.is_a_vbf==1) {      // Close vbf file and delete class

    fprintf(stderr,"\n     number of vbf packets in data file: %d\n",
            (oper.writeVBF)->getEventNumber());
    fprintf(stderr,"     number of vbf data packets: %d\n",
            (oper.writeVBF)->getEventNumber() -
            (oper.writeVBF)->getPedEventCount() - 1);
    fprintf(stderr,"     number of vbf pedestal packets: %d\n",
            (oper.writeVBF)->getPedEventCount());
    
    (oper.writeVBF)->finishVBF();
    delete oper.writeVBF;
    if (oper.vbfp.is_a_pedvbf==1) {
      fprintf(stderr,
              "\n    number of vbf packets in pedestal file: %d\n",
              (oper.writepedVBF)->getPedEventCount());
      (oper.writepedVBF)->finishVBF();
      delete oper.writepedVBF;
    }
  }
